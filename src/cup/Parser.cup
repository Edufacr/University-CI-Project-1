import java_cup.runtime.*;
import SemanticAnalysis.*;




parser code{:

    ISemanticAnalyzer sa = SemanticAnalyzer.getInstance();

    // Syntaxis
    public void report_error(String sectionName){
        System.out.println("Sección: " + sectionName );
    }

    public void report_error(String sectionName, String message){
        report_error(sectionName);
        System.out.println(message);
    }

    public void syntax_error(Symbol s){
        System.out.println("------------------");
        System.out.println("Error de Sintaxis:");
        if(s.value == null){
            System.out.println("Unexpected EOF: More Tokens Expected " );
        }
        else{
            System.out.println("Unexpected Token: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
        }
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        if(s.value == null){
            System.out.println("Unrecovered Syntax Error At EOF: More tokens needed to recover.");
        }
        else {
            System.out.println("Unrecovered Syntax Error: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
        }
    }
:};

/* 
--------------
Terminals 

n---------------
*/

// Identifiers
terminal String IDENTIFIER; 
// Special Symbols
terminal String SEMICOLON, COLON, ASSIGN, COMMA, RBRACK, LBRACK, LPAREN, RPAREN, LCURLY, RCURLY;
// Mandatory Reserved Words
terminal String CONST, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, WHILE;
// Mandatory Types
terminal String CHAR, INT, LONG, SHORT, VOID;
// Mandatory Functions
terminal String READ, WRITE;
// Numeric Operators
terminal String PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, MULT, DIV, MOD;
terminal String PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;

//Boolean Operators
//                                          <=          >=              >       <
terminal AND, OR, EQUALS, DISTINCT, NOT, LESS_EQUALS, GREATER_EQUALS, GREATER, LESS;

//Literals
terminal String NUMCONST;
terminal String STRINGS;
terminal String CHARS;

// Extra Reserved Words
terminal STATIC;
/* 
--------------
Non terminals
--------------
*/

// Program Structure
non terminal program, decls, vars, functions;

// Const & Vars Declaration
non terminal constDecl, varDecl, varDeclList;

// Literals
non terminal String literals;

// Types
non terminal String typeSpec;

// Functions
non terminal funcDecl, paramList, params, funcBody;

// CodeBlock
non terminal codeBlock;

// Statements
non terminal stmtList, stmt, exprStmt,functionsStmt;

// Expressions
non terminal expr, sumExpr, simpleExpr;

// Assignations
non terminal assignOp;

// Bool Expr
non terminal andExpr, unaryRelExpr, relExpr, relOp;

// SumExpression
non terminal mulExpr, unaryExpr, factor, immutable;

// Operators
non terminal sumOp, mulOp, unaryOp, doubleUnaryOp;

// Calls
non terminal call, args, argList;

// Flow Control 
non terminal ifStmt,elseStmt, iterStmt, switchStmt;

// Switch 
non terminal switchBody, caseList, case, defaultCase;

// Commmands
non terminal returnStmt, continueStmt, breakStmt;



/* 
--------------
Precedence
--------------
*/

start with program;

/* 
--------------
Grammar Rules
--------------
*/

// Program Structure
program   ::=     decls {: sa.endOfCode(); :}
                ;

decls     ::=     vars functions
                | functions
                | vars error  {: report_error("Estructura del Programa","Se debe especificar al menos una función"); :}
                ;

vars      ::=     vars varDecl
                | vars constDecl
                | varDecl
                | constDecl
                ;

// Const & Vars Declaration
constDecl ::=     CONST typeSpec IDENTIFIER ASSIGN literals SEMICOLON
                | CONST error 
                    {: report_error("Declaracion de Constante"); :} 
                  SEMICOLON 
                ;

varDecl   ::=     typeSpec:type varDeclList SEMICOLON {: sa.insertVar(); :}
                | typeSpec error
                  {: report_error("Declaracion de Variable"); :}
                  SEMICOLON 
                ; 

varDeclList ::=   varDeclList COMMA IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :}
                | IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :}
                ;

// Functions
functions ::=     functions funcDecl
                | funcDecl
                | error {: report_error("Funciones del Programa"); :} funcDecl  
                ;

funcDecl ::=      typeSpec IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :} LPAREN {: sa.saveFuncDecl(); :} params RPAREN {: sa.insertFuncDecl(); :} funcBody
                | VOID:type {: sa.saveType(type, typeleft, typeright); :} IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :} LPAREN {: sa.saveFuncDecl(); :} params RPAREN {: sa.insertFuncDecl(); :}  funcBody
                | error {: report_error("Declaracion de Funcion"); :} funcBody                                       
                ;

params ::=        paramList
                | 
                ; //epsilon

paramList ::=     typeSpec IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :} COMMA paramList
                | typeSpec IDENTIFIER:id {: sa.saveIdentifier(id, idleft, idright); :}
                ;

// FuncBody
funcBody ::=      LCURLY vars stmtList RCURLY 
                | LCURLY vars RCURLY 
                | LCURLY stmtList RCURLY
                | LCURLY RCURLY
                | LCURLY vars error RCURLY                      {: report_error("Statements de la Funcion"); :}  
                | LCURLY error RCURLY                           {: report_error("Cuerpo de la funcion"); :}     
                ;

// CodeBlock
codeBlock ::=     LCURLY stmtList RCURLY
                | LCURLY RCURLY
                | LCURLY error RCURLY                           {: report_error("Bloque de Codigo"); :}     
                ;

// Statements
stmtList ::=      stmtList stmt
                | stmt
                ;

stmt ::=          exprStmt
                | ifStmt
                | iterStmt
                | returnStmt 
                | continueStmt 
                | breakStmt
                | functionsStmt 
                | switchStmt
                ;

exprStmt ::=      expr SEMICOLON
                | error SEMICOLON                                                          {: report_error("Expresion Statement"); :}
                ; 
     
// Flow Control 
ifStmt ::=        IF:ifToken {: sa.saveIf(ifTokenleft,ifTokenright); :} LPAREN expr RPAREN {: sa.testIf(); :} codeBlock elseStmt
                | IF error {: report_error("If statement"); :} codeBlock elseStmt                                                 
                ;

elseStmt ::=      ELSE {: sa.saveElse(); :} codeBlock {: sa.endIf(); :}
                | 
                ; // epsilon

iterStmt ::=      WHILE:whileToken {: sa.saveWhile(whileTokenleft,whileTokenright); :} LPAREN expr RPAREN {: sa.testWhile(); :} codeBlock {: sa.endWhile(); :}
                | WHILE error {: report_error("While statement"); :} codeBlock
                | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN codeBlock
                | FOR error {: report_error("For statement"); :} codeBlock                                                  
                ;

returnStmt ::=    RETURN expr SEMICOLON
                | RETURN SEMICOLON
                | RETURN error {: report_error("Return statement"); :} SEMICOLON                                               
                ;

breakStmt ::=     BREAK:id {: sa.checkInLoop(id, idleft, idright); :} SEMICOLON; 

continueStmt ::=  CONTINUE:id {: sa.checkInLoop(id, idleft, idright); :} SEMICOLON;
 
functionsStmt ::= READ LPAREN IDENTIFIER RPAREN SEMICOLON
                  | READ LPAREN RPAREN SEMICOLON
                  | READ error 
                    {: report_error("Read instruction"); :}
                    SEMICOLON                                                
                  | WRITE LPAREN argList RPAREN SEMICOLON 
                  | WRITE error 
                    {: report_error("Write instruction"); :}
                    SEMICOLON                                                
                  ;

switchStmt ::=        SWITCH LPAREN IDENTIFIER RPAREN switchBody
                    | SWITCH error 
                      {: report_error("Switch Statement"); :}
                      switchBody                                              
                    ;

switchBody ::=        LCURLY caseList RCURLY                 
                    | LCURLY error 
                      {: report_error("Switch Body"); :}
                      RCURLY                     
                    ;

caseList ::=          caseList case 
                    | case
                    | caseList defaultCase
                    | defaultCase
                    ;

case ::=              CASE NUMCONST COLON stmtList
                    | CASE error stmtList                                                {: report_error("Case Statement"); :}
                    ;

defaultCase ::=       DEFAULT COLON stmtList
                    | DEFAULT error stmtList                                             {: report_error("Default Statement"); :}
                    ;
            
// Expressions
// Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.
expr ::=            IDENTIFIER:id {: sa.addExpressionVar(id, idleft, idright); :} assignOp expr {: sa.evalBinary(idleft,idright); :}
                |   IDENTIFIER error        {: report_error("Assign Statement"); :}
                |   simpleExpr 
                ; 

assignOp ::=      ASSIGN:op       {: sa.addOperator(op, opleft, opright); :}
                | PLUS_ASSIGN:op  {: sa.addOperator(op, opleft, opright); :}
                | MINUS_ASSIGN:op {: sa.addOperator(op, opleft, opright); :}
                | MULT_ASSIGN:op  {: sa.addOperator(op, opleft, opright); :}
                | DIV_ASSIGN:op   {: sa.addOperator(op, opleft, opright); :}
                | MOD_ASSIGN:op   {: sa.addOperator(op, opleft, opright); :}
                ; 
                
simpleExpr ::=    simpleExpr OR andExpr     {: sa.evalBinary(0,0); :}
                | andExpr
                ;
andExpr ::=       andExpr AND unaryRelExpr  {: sa.evalBinary(0,0); :}
                | unaryRelExpr
                ;
unaryRelExpr ::=  NOT unaryRelExpr 
                | relExpr
                ;

relExpr ::=       sumExpr relOp sumExpr     {: sa.evalBinary(0,0); :}
                | sumExpr
                ;

relOp ::=         LESS_EQUALS:op {: sa.addOperator(op, opleft, opright); :}
                | LESS:op {: sa.addOperator(op, opleft, opright); :}
                | GREATER:op {: sa.addOperator(op, opleft, opright); :}
                | GREATER_EQUALS:op {: sa.addOperator(op, opleft, opright); :}
                | EQUALS:op {: sa.addOperator(op, opleft, opright); :}
                | DISTINCT:op {: sa.addOperator(op, opleft, opright); :}
                ;

sumExpr ::=       sumExpr sumOp mulExpr     {: sa.evalBinary(0,0); :}
                | mulExpr
                ;

sumOp ::=     PLUS:op       {: sa.addOperator(op, opleft, opright); :}
            | MINUS:op      {: sa.addOperator(op, opleft, opright); :};

mulExpr ::=   mulExpr mulOp unaryExpr {: sa.evalBinary(0,0); :}
            | unaryExpr
            ;

mulOp ::=     MULT:op       {: sa.addOperator(op, opleft, opright); :}
            | DIV:op       {: sa.addOperator(op, opleft, opright); :}
            | MOD:op       {: sa.addOperator(op, opleft, opright); :};

unaryExpr ::= unaryOp factor
            | factor
            | doubleUnaryOp:op IDENTIFIER:id {: sa.addExpressionVar(id, idleft, idright); sa.evalUnary(opleft,opright); :}
            | IDENTIFIER:id doubleUnaryOp:op {: sa.addExpressionVar(id, idleft, idright); sa.evalUnary(opleft,opright); :}
            ;
unaryOp ::=   MINUS:op      {: sa.addOperator(op, opleft, opright); :}
            | PLUS:op       {: sa.addOperator(op, opleft, opright); :}
            ; 

doubleUnaryOp ::=     PLUS_PLUS:op       {: sa.addOperator(op, opleft, opright); :}
                    | MINUS_MINUS:op     {: sa.addOperator(op, opleft, opright); :}
                    ;

factor ::=    immutable 
            | IDENTIFIER:id               {: sa.addExpressionVar(id, idleft, idright); :}
            ;

immutable ::=     LPAREN expr RPAREN 
                | literals
                | call
                ;

call ::=    IDENTIFIER:id LPAREN {: sa.saveFuncCall(id, idleft, idright); :} args RPAREN  {: sa.checkFunc(id, idleft, idright); :};

args ::=    argList 
            | ;

argList ::=     argList COMMA expr 
                | expr
                ;

// Literals
literals ::=      NUMCONST:num    {: sa.addConstInt(num); :}
                | CHARS:chars     {: sa.addConstCharString(chars); :}
                | STRINGS:strings {: sa.addConstCharString(strings); :}
                ;

// Types
typeSpec ::=      INT:type    {: sa.saveType(type, typeleft, typeright); :}
                | CHAR:type   {: sa.saveType(type, typeleft, typeright); :}
                | LONG:type   {: sa.saveType(type, typeleft, typeright); :}
                | SHORT:type  {: sa.saveType(type, typeleft, typeright); :}
                ;