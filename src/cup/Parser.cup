/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error de Sintaxis: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Unrecovered Syntax Error: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }
:}

/* 
--------------
Terminals
--------------
*/

// Identifiers
terminal IDENTIFIER; 
// Special Symbols
terminal SEMICOLON, COLON, ASSIGN, COMMA, RBRACK, LBRACK, LPAREN, RPAREN, LCURLY, RCURLY;
// Mandatory Reserved Words
terminal CONST, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, VOID, WHILE;
// Mandatory Types
terminal CHAR, INT, LONG, SHORT;
// Mandatory Functions
terminal READ, WRITE;
// Numeric Operators
terminal PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, MULT, DIV, MOD;
terminal PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;

//Boolean Operators
//                                          <=          >=              >       <
terminal AND, OR, EQUALS, DISTINCT, NOT, LESS_EQUALS, GREATER_EQUALS, GREATER, LESS;

//Literals
terminal Integer NUMCONST; 
terminal String  STRINGS;
terminal Character CHARS;

// Extra Reserved Words
terminal STATIC;

/* 
--------------
Non terminals
--------------
*/

// Program Structure
non terminal program, decls, vars, functions;

// Const & Vars Declaration
non terminal constDecl, varDecl, varDeclList;

// Literals
non terminal literals;

// Types
non terminal typeSpec;

// Functions
non terminal funcDecl, paramList, params;

// CodeBlock
non terminal codeBlock;

// Statements
non terminal stmtList, stmt, exprStmt,functionsStmt;

// Expressions
non terminal expr, sumExpr, simpleExpr;
// Bool Expr
non terminal andExpr, unaryRelExpr, relExpr, relOp;

// SumExpression
non terminal mulExpr, unaryExpr, factor, immutable;

// Operators
non terminal sumOp, mulOp, unaryOp;

// Calls
non terminal call, args, argList;

// Flow Control 
non terminal ifStmt, iterStmt, switchStmt;

// Switch 
non terminal switchBody, caseList, case, defaultCase;

// Commmands
non terminal returnStmt, continueStmt, breakStmt;


start with program;


/* 
--------------
Grammar Rules
--------------
*/

// Program Structure
program  ::=       decls;

decls    ::=      vars functions
                  | functions
                  | vars error 
                  ;

vars    ::=       vars varDecl
                | vars constDecl
                | varDecl
                | constDecl;

// Const & Vars Declaration
constDecl ::=     CONST typeSpec IDENTIFIER ASSIGN literals SEMICOLON;

varDecl   ::=     typeSpec varDeclList SEMICOLON
                | error SEMICOLON; // Tirar un error hasta ; pero se recupera 

varDeclList ::=   varDeclList COMMA IDENTIFIER 
               | IDENTIFIER;

// Functions
functions ::=       functions funcDecl
                 |  funcDecl;

funcDecl ::=      typeSpec IDENTIFIER LPAREN params RPAREN codeBlock
                | VOID IDENTIFIER LPAREN params RPAREN  codeBlock;

paramList ::=      typeSpec IDENTIFIER COMMA paramList
                |  typeSpec IDENTIFIER;

params ::=        paramList 
                | ; //epsilon

/*

    En el cuerpo de una función puede venir expresiones, o estructuras de control, instrucciones como read, 
    write, break, continue
    • Las estructuras de control son: if, if-else, for, while, switch.
    • Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.

    • En el caso de las estructuras de control if, for y while en su expresión no deben validar que sea booleana, 
    puede ser cualquier tipo de expresión incluso una asignación. En el caso de switch debe validar que la 
    expresión es numérica
    
    Errores:

    Buscar errores por bloque
    Por ejemplo declaraciones de variables error, if error, while
    Se puede hacer más detallado cómo en la exp del if o en el body
    No se puede recuper de todos los errores
    Lo importante es que se ubique en la linea y en el bloque donde esta
    
    Preguntas:
    Se pueden declarar solo variables dentro de una foo?
        Se pueden declarar variables del todo dentro de una función
    Las asignaciones se consideran numericas para el switch?
    Se pueden hacer bloques sin nada?
    Se pueden poner identifiers como exp?
    Donde se pone el DO?
    i++ se tiene que definir o solo ++i

*/

// CodeBlock
codeBlock ::=   LCURLY vars stmtList RCURLY 
                    | LCURLY vars RCURLY 
                    | LCURLY stmtList RCURLY
                    | LCURLY RCURLY
                    ;
// Statements
stmtList ::=    stmtList stmt
                | stmt;

stmt ::=        exprStmt
                | ifStmt
                | iterStmt
                | returnStmt 
                | continueStmt 
                | breakStmt
                | functionsStmt 
                | switchStmt 
                ;

exprStmt ::=    expr SEMICOLON;
                //| SEMICOLON;

// Flow Control 
ifStmt ::=            IF LPAREN expr RPAREN codeBlock
                    | IF LPAREN expr RPAREN codeBlock ELSE codeBlock;

iterStmt ::=          WHILE LPAREN expr RPAREN codeBlock
                    | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN codeBlock
                    ;

returnStmt ::=        RETURN expr SEMICOLON
                    | RETURN SEMICOLON
                    ;

breakStmt ::=         BREAK SEMICOLON;

continueStmt ::=      CONTINUE SEMICOLON;
 
functionsStmt ::=     READ LPAREN IDENTIFIER RPAREN SEMICOLON
                    | READ LPAREN RPAREN SEMICOLON
                    | WRITE LPAREN argList RPAREN SEMICOLON
                    ;

switchStmt ::=        SWITCH LPAREN expr RPAREN switchBody; // TODO: change to numeric expression

switchBody ::=        LCURLY caseList RCURLY;

caseList ::=          caseList case 
                    | case
                    | caseList defaultCase
                    | defaultCase
                    ;

case ::=              CASE NUMCONST COLON stmtList;

defaultCase ::=       DEFAULT COLON stmtList;

// Expressions
// Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.
expr ::=            IDENTIFIER ASSIGN expr
                |   IDENTIFIER PLUS_ASSIGN expr
                |   IDENTIFIER MINUS_ASSIGN expr
                |   IDENTIFIER MULT_ASSIGN expr
                |   IDENTIFIER DIV_ASSIGN expr
                |   IDENTIFIER MOD_ASSIGN expr
                |   simpleExpr
                ; 
              //  ; // TODO: Tomar en cuenta la expresion del switch que es solo numerica 

simpleExpr ::=    simpleExpr OR andExpr 
                | andExpr
                ;
andExpr ::=       andExpr AND unaryRelExpr 
                | unaryRelExpr
                ;
unaryRelExpr ::=  NOT unaryRelExpr 
                | relExpr
                ;
relExpr ::=       sumExpr relOp sumExpr 
                | sumExpr
                ;

relOp ::=         LESS_EQUALS 
                | LESS 
                | GREATER 
                | GREATER_EQUALS 
                | EQUALS 
                | DISTINCT
                ;

sumExpr ::=       sumExpr sumOp mulExpr 
                | mulExpr
                ;

sumOp ::=     PLUS 
            | MINUS;

mulExpr ::=   mulExpr mulOp unaryExpr 
            | unaryExpr;

mulOp ::=     MULT 
            | DIV 
            | MOD;

unaryExpr ::= unaryOp unaryExpr
            | factor;

unaryOp ::=   MINUS
            | PLUS
            | PLUS_PLUS
            | MINUS_MINUS
            ;

factor ::= immutable | IDENTIFIER;

immutable ::=   LPAREN expr RPAREN 
                | literals
                | call
                ;
            //| constant //como NUMCONST | CHARCONST | STRINGCONST | true | false pero no se si aplican

call ::=    IDENTIFIER LPAREN args RPAREN;

args ::=    argList 
            | ;

argList ::=     argList COMMA expr 
                | expr;


// Literals
literals ::=      NUMCONST
                | CHARS
                | STRINGS
                ;

// Types
typeSpec ::=      INT 
                | CHAR 
                | LONG 
                | SHORT;