/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error de Sintaxis: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Unrecovered Syntax Error: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }
:}

/* 
--------------
Terminals
--------------
*/

// Identifiers
terminal IDENTIFIER; 
// Special Symbols
terminal SEMICOLON, ASSIGN, COMMA, RBRACK, LBRACK, LPAREN, RPAREN, LCURLY, RCURLY;
// Mandatory Reserved Words
terminal CONST, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, VOID, WHILE;
// Mandatory Types
terminal CHAR, INT, LONG, SHORT;
// Mandatory Functions
terminal READ, WRITE;
// Numeric Operators
terminal PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, MULT, DIV, MOD;
terminal PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;

//Boolean Operators
//                                          <=          >=              >       <
terminal AND, OR, EQUAL, DISTINCT, NOT, LESS_EQUALS, GREATER_EQUALS, GREATER, LESS;

//Literals
terminal Integer NUMCONST; 
terminal String  STRINGS;
terminal Character CHARS;

// Extra Reserved Words
terminal STATIC;

/* 
--------------
Non terminals
--------------
*/

// Program Structure
non terminal program, decls, vars, functions, functions_;

// Const & Vars Declaration
non terminal constDecl, varDecl, varDeclList;

// Literals
non terminal literals;

// Types
non terminal typeSpec;

// Functions
non terminal funcDecl, paramList, params;

// CodeBlock
non terminal codeBlock;

// Statements
non terminal stmtList, stmt, exprStmt;

// Expressions
non terminal expr, numExpr, sumExp, sumOp, mulExp, mulop, unaryExp, factor, immutable, call, args, argList, unaryop;

// Flow Control 
non terminal ifStmt, iterStmt, switchStmt;

// Commmands
non terminal returnStmt, continueStmt, breakStmt;


start with program;


/* 
--------------
Grammar Rules
--------------
*/

// Program Structure
program  ::=       decls;

decls    ::=      vars functions
                  | functions
                  | vars error 
                  ;

vars    ::=       vars varDecl
                | vars constDecl
                | varDecl
                | constDecl;

// Const & Vars Declaration
constDecl ::=     CONST typeSpec IDENTIFIER ASSIGN literals SEMICOLON;

varDecl   ::=     typeSpec varDeclList SEMICOLON
                | error SEMICOLON; // Tirar un error hasta ; pero se recupera 

varDeclList ::=   varDeclList COMMA IDENTIFIER 
               | IDENTIFIER;

// Functions
functions ::=       functions funcDecl
                 |  funcDecl;

funcDecl ::=      typeSpec IDENTIFIER LPAREN params RPAREN codeBlock
                | VOID IDENTIFIER LPAREN params RPAREN  codeBlock;

paramList ::=      typeSpec IDENTIFIER COMMA paramList
                |  typeSpec IDENTIFIER;

params ::=        paramList 
                | ; //epsilon

/*

    En el cuerpo de una función puede venir expresiones, o estructuras de control, instrucciones como read, 
    write, break, continue
    • Las estructuras de control son: if, if-else, for, while, switch.
    • Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.

    • En el caso de las estructuras de control if, for y while en su expresión no deben validar que sea booleana, 
    puede ser cualquier tipo de expresión incluso una asignación. En el caso de switch debe validar que la 
    expresión es numérica

    
    Preguntas:
    Se pueden declarar solo variables dentro de una foo?
    Las asignaciones se consideran numericas para el switch?
    Se pueden hacer bloques sin nada?
    Se pueden poner identifiers como exp?
    Donde se pone el DO?

*/

// CodeBlock
codeBlock ::=   LCURLY vars stmtList RCURLY 
                    | LCURLY vars RCURLY 
                    | LCURLY stmtList RCURLY
                    | LCURLY RCURLY
                    ;
// Statements
stmtList ::=    stmtList stmt
                | stmt;

stmt ::=        exprStmt
                | ifStmt
                | iterStmt
                | returnStmt 
                | continueStmt 
                | breakStmt 
                ;
                // | switchStmt 

exprStmt ::=    expr SEMICOLON;
                //| SEMICOLON;

// Flow Control 
ifStmt ::=      IF LPAREN expr RPAREN codeBlock
                | IF LPAREN expr RPAREN codeBlock ELSE codeBlock;

iterStmt ::=    WHILE LPAREN expr RPAREN codeBlock
                | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN codeBlock
                ;

returnStmt ::=  RETURN expr SEMICOLON;

breakStmt ::=   BREAK SEMICOLON;

continueStmt ::= CONTINUE SEMICOLON;

// Expressions
// Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.
expr ::=            IDENTIFIER ASSIGN expr
                |   IDENTIFIER PLUS_ASSIGN expr
                |   IDENTIFIER MINUS_ASSIGN expr
                |   IDENTIFIER MULT_ASSIGN expr
                |   IDENTIFIER DIV_ASSIGN expr
                |   IDENTIFIER MOD_ASSIGN expr
                |   IDENTIFIER PLUS_PLUS expr
                |   IDENTIFIER MINUS_MINUS expr
                |   IDENTIFIER EQUAL expr
                |   IDENTIFIER LESS_EQUALS expr
                |   IDENTIFIER GREATER_EQUALS expr
                |   IDENTIFIER DISTINCT expr
                |   IDENTIFIER OR expr
                |   IDENTIFIER AND expr
                |   sumExp
                ; 
              //  ; // TODO: Tomar en cuenta la expresion del switch que es solo numerica 

sumExp ::= sumExp sumOp mulExp | mulExp;

sumOp ::= PLUS | MINUS;

mulExp ::= mulExp mulop unaryExp | unaryExp;

mulop ::=  MULT | DIV | MOD;

unaryExp ::= unaryop unaryExp | factor;

unaryop ::= MINUS | MULT;

factor ::= immutable | IDENTIFIER;

immutable ::= LPAREN expr RPAREN 
            | call
            | literals;
            //| constant //como NUMCONST | CHARCONST | STRINGCONST | true | false pero no se si aplican

call ::= IDENTIFIER LPAREN args RPAREN;

args ::= argList 
        | ;

argList ::= argList COMMA expr | expr;


// Literals
literals ::=      NUMCONST
                | CHARS
                | STRINGS
                ;

// Types
typeSpec ::=      INT 
                | CHAR 
                | LONG 
                | SHORT;