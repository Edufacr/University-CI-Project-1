/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code
{:

    public void report_error(String sectionName){
        System.out.println("Sección: " + sectionName );
    }

    public void report_error(String sectionName, String message){
        report_error(sectionName);
        System.out.println(message);
    }

    public void syntax_error(Symbol s){
        System.out.println("------------------");
        System.out.println("Error de Sintaxis:");
        // Cuando no hay nada despues no es unexpected token
        System.out.println("Unexpected Token: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Unrecovered Syntax Error: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }
:}

/* 
--------------
Terminals
--------------
*/

// Identifiers
terminal IDENTIFIER; 
// Special Symbols
terminal SEMICOLON, COLON, ASSIGN, COMMA, RBRACK, LBRACK, LPAREN, RPAREN, LCURLY, RCURLY;
// Mandatory Reserved Words
terminal CONST, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, VOID, WHILE;
// Mandatory Types
terminal CHAR, INT, LONG, SHORT;
// Mandatory Functions
terminal READ, WRITE;
// Numeric Operators
terminal PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, MULT, DIV, MOD;
terminal PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;

//Boolean Operators
//                                          <=          >=              >       <
terminal AND, OR, EQUALS, DISTINCT, NOT, LESS_EQUALS, GREATER_EQUALS, GREATER, LESS;

//Literals
terminal Integer NUMCONST; 
terminal String  STRINGS;
terminal Character CHARS;

// Extra Reserved Words
terminal STATIC;

/* 
--------------
Non terminals
--------------
*/

// Program Structure
non terminal program, decls, vars, functions;

// Const & Vars Declaration
non terminal constDecl, varDecl, varDeclList;

// Literals
non terminal literals;

// Types
non terminal typeSpec;

// Functions
non terminal funcDecl, paramList, params, funcBody;

// CodeBlock
non terminal codeBlock;

// Statements
non terminal stmtList, stmt, exprStmt,functionsStmt;

// Expressions
non terminal expr, sumExpr, simpleExpr;
// Bool Expr
non terminal andExpr, unaryRelExpr, relExpr, relOp;

// SumExpression
non terminal mulExpr, unaryExpr, factor, immutable;

// Operators
non terminal sumOp, mulOp, unaryOp;

// Calls
non terminal call, args, argList;

// Flow Control 
non terminal ifStmt, iterStmt, switchStmt;

// Switch 
non terminal switchBody, caseList, case, defaultCase;

// Commmands
non terminal returnStmt, continueStmt, breakStmt;


start with program;


/* 
--------------
Grammar Rules
--------------
*/

// Program Structure
program  ::=       decls;

decls    ::=      vars functions
                  | functions
                  | vars error      {: report_error("Estructura del Programa","Se debe especificar al menos una función"); :}
                  ;

vars    ::=       vars varDecl
                | vars constDecl
                | varDecl
                | constDecl;

// Const & Vars Declaration
constDecl ::=     CONST typeSpec IDENTIFIER ASSIGN literals SEMICOLON
                | CONST error SEMICOLON {: report_error("Declaracion de Constante"); :}
                ;

varDecl   ::=     typeSpec varDeclList SEMICOLON
                | typeSpec error SEMICOLON {: report_error("Declaracion de Variable"); :}
                ; 

varDeclList ::=   varDeclList COMMA IDENTIFIER
                | IDENTIFIER
                ;

// Functions
functions ::=       functions funcDecl
                 |  funcDecl;

funcDecl ::=      typeSpec IDENTIFIER LPAREN params RPAREN funcBody
                | VOID IDENTIFIER LPAREN params RPAREN  funcBody
                | error funcBody                                       {: report_error("Declaracion de Funcion"); :}
                ;

params ::=        paramList 
                | ; //epsilon

paramList ::=      typeSpec IDENTIFIER COMMA paramList
                |  typeSpec IDENTIFIER;



/*

    En el cuerpo de una función puede venir expresiones, o estructuras de control, instrucciones como read, 
    write, break, continue
    • Las estructuras de control son: if, if-else, for, while, switch.
    • Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.

    • En el caso de las estructuras de control if, for y while en su expresión no deben validar que sea booleana, 
    puede ser cualquier tipo de expresión incluso una asignación. En el caso de switch debe validar que la 
    expresión es numérica

    Consideraciones ultimo video:

    
    Errores:

    Buscar errores por bloque
    Por ejemplo declaraciones de variables error, if error, while
    Se puede hacer más detallado cómo en la exp del if o en el body
    No se puede recuper de todos los errores
    Lo importante es que se ubique en la linea y en el bloque donde esta
    
    Preguntas:

    i++ se tiene que definir o solo ++i

*/

// FuncBody
funcBody ::=   LCURLY vars stmtList RCURLY 
                    | LCURLY vars RCURLY 
                    | LCURLY stmtList RCURLY
                    | LCURLY RCURLY
                    | LCURLY error RCURLY                           {: report_error("Cuerpo de la funcion"); :}     
                    ;

// CodeBlock
codeBlock ::=         LCURLY stmtList RCURLY
                    | LCURLY RCURLY
                    | LCURLY error RCURLY                           {: report_error("Bloque de Codigo"); :}     
                    ;

// Statements
stmtList ::=    stmtList stmt
                | stmt;

stmt ::=        exprStmt
                | ifStmt
                | iterStmt
                | returnStmt 
                | continueStmt 
                | breakStmt
                | functionsStmt 
                | switchStmt 
                ;

exprStmt ::=    expr SEMICOLON
                | error SEMICOLON                                                          {: report_error("Expresion Statement"); :}
                ; 
     
// Flow Control 
ifStmt ::=            IF LPAREN expr RPAREN codeBlock
                    | IF LPAREN expr RPAREN codeBlock ELSE codeBlock
                    | IF error codeBlock                                                   {: report_error("If statement"); :}
                    ;

iterStmt ::=          WHILE LPAREN expr RPAREN codeBlock
                    | WHILE error codeBlock                                                {: report_error("While statement"); :}
                    | FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN codeBlock
                    | FOR error codeBlock                                                  {: report_error("For statement"); :}
                    ;

returnStmt ::=        RETURN expr SEMICOLON
                    | RETURN SEMICOLON
                    ;

breakStmt ::=         BREAK SEMICOLON;

continueStmt ::=      CONTINUE SEMICOLON;
 
functionsStmt ::=     READ LPAREN IDENTIFIER RPAREN SEMICOLON
                    | READ LPAREN RPAREN SEMICOLON
                    | READ error SEMICOLON                                                {: report_error("Read instruction"); :}
                    | WRITE LPAREN argList RPAREN SEMICOLON
                    | WRITE error SEMICOLON                                                {: report_error("Write instruction"); :}
                    ;

switchStmt ::=        SWITCH LPAREN IDENTIFIER RPAREN switchBody
                    | SWITCH error switchBody                                                {: report_error("Switch Statement"); :}
                    ;

switchBody ::=        LCURLY caseList RCURLY;

caseList ::=          caseList case 
                    | case
                    | caseList defaultCase
                    | defaultCase
                    ;

case ::=              CASE NUMCONST COLON stmtList
                    | CASE error stmtList                                                {: report_error("Case Statement"); :}
                    ;

defaultCase ::=       DEFAULT COLON stmtList
                    | DEFAULT error stmtList                                             {: report_error("Default Statement"); :};

// Expressions
// Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.
expr ::=            IDENTIFIER ASSIGN expr
                |   IDENTIFIER PLUS_ASSIGN expr
                |   IDENTIFIER MINUS_ASSIGN expr
                |   IDENTIFIER MULT_ASSIGN expr
                |   IDENTIFIER DIV_ASSIGN expr
                |   IDENTIFIER MOD_ASSIGN expr
                |   simpleExpr
                ; 

simpleExpr ::=    simpleExpr OR andExpr 
                | andExpr
                ;
andExpr ::=       andExpr AND unaryRelExpr 
                | unaryRelExpr
                ;
unaryRelExpr ::=  NOT unaryRelExpr 
                | relExpr
                ;

// ?Equals y Distinct solo para sumExp?
relExpr ::=       sumExpr relOp sumExpr 
                | sumExpr
                ;

relOp ::=         LESS_EQUALS 
                | LESS 
                | GREATER 
                | GREATER_EQUALS 
                | EQUALS 
                | DISTINCT
                ;

sumExpr ::=       sumExpr sumOp mulExpr 
                | mulExpr
                ;

sumOp ::=     PLUS 
            | MINUS;

mulExpr ::=   mulExpr mulOp unaryExpr 
            | unaryExpr;

mulOp ::=     MULT 
            | DIV 
            | MOD;

//Hay que revisar
unaryExpr ::= unaryOp unaryExpr
            | factor;

unaryOp ::=   MINUS
            | PLUS
            | PLUS_PLUS
            | MINUS_MINUS
            ;

factor ::= immutable | IDENTIFIER;

immutable ::=   LPAREN expr RPAREN 
                | literals
                | call
                ;

call ::=    IDENTIFIER LPAREN args RPAREN;

args ::=    argList 
            | ;

argList ::=     argList COMMA expr 
                | expr;


// Literals
literals ::=      NUMCONST
                | CHARS
                | STRINGS
                ;

// Types
typeSpec ::=      INT 
                | CHAR 
                | LONG 
                | SHORT;