/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error de Sintaxis: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Unrecovered Syntax Error: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }
:}

/* 
--------------
Terminals
--------------
*/

// Identifiers
terminal IDENTIFIER; 
// Special Symbols
terminal SEMICOLON, ASSIGN, COMMA, RBRACK, LBRACK, LPAREN, RPAREN, LCURLY, RCURLY;
// Mandatory Reserved Words
terminal CONST, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, VOID, WHILE;
// Mandatory Types
terminal CHAR, INT, LONG, SHORT;
// Mandatory Functions
terminal READ, WRITE;
// Numeric Operators
terminal PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, MULT, DIV, MOD;
terminal PLUS_ASSIGN, MINUS_ASSIGN, MULT_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;

//Boolean Operators
//                                          <=          >=              >       <
terminal AND, OR, EQUAL, DISTINCT, NOT, LESS_EQUALS, GREATER_EQUALS, GREATER, LESS;

//Literals
terminal Integer NUMCONST; 

// Extra Reserved Words
terminal STATIC;

/* 
--------------
Non terminals
--------------
*/

// Program Structure
non terminal program, decls, vars, functions, functions_;

// Const & Vars Declaration
non terminal constDecl, varDecl, varDeclList;

// Literals
non terminal literals;

// Types
non terminal typeSpec;

// Functions
non terminal funcDecl, paramList, params;

// CodeBlock
non terminal codeBlock;

// Statements
non  terminal stmtList, stmt, exprStmt;

// Expressions
non terminal expr, numExpr;

// Flow Control 
non terminal ifStmt, whileStmt, forStmt, switchStmt;

// Commmands
non terminal returnStmt, continueStmt, breakStmt;



start with program;


/* 
--------------
Grammar Rules
--------------
*/

// Program Structure
program  ::=       decls;

decls    ::=      vars functions
                  | functions
                  | vars error 
                  ;

vars    ::=       vars varDecl
                | vars constDecl
                | varDecl
                | constDecl;

// Const & Vars Declaration
constDecl ::=     CONST typeSpec IDENTIFIER ASSIGN literals SEMICOLON;

varDecl   ::=     typeSpec varDeclList SEMICOLON
                | error SEMICOLON; // Tirar un error hasta ; pero se recupera 

varDeclList ::=   varDeclList COMMA IDENTIFIER 
               | IDENTIFIER;

// Functions
functions ::=       functions funcDecl
                 |  funcDecl;

funcDecl ::=      typeSpec IDENTIFIER LPAREN params RPAREN codeBlock
                | VOID IDENTIFIER LPAREN params RPAREN  codeBlock;

paramList ::=      typeSpec IDENTIFIER COMMA paramList
                |  typeSpec IDENTIFIER;

params ::=        paramList 
                | ; //epsilon

/*

    En el cuerpo de una función puede venir expresiones, o estructuras de control, instrucciones como read, 
    write, break, continue
    • Las estructuras de control son: if, if-else, for, while, switch.
    • Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.

    • En el caso de las estructuras de control if, for y while en su expresión no deben validar que sea booleana, 
    puede ser cualquier tipo de expresión incluso una asignación. En el caso de switch debe validar que la 
    expresión es numérica

    
    Preguntas:
    Se pueden declarar solo variables dentro de una foo?
    Las asignaciones se consideran numericas para el switch?
    Se pueden hacer bloques sin nada?

*/

// CodeBlock
codeBlock ::=   LCURLY vars stmtList RCURLY 
                    | LCURLY vars RCURLY 
                    | LCURLY stmtList RCURLY
                    | LCURLY RCURLY
                    ;
// Statements
stmtList ::=    stmtList stmt
                | stmt;

stmt ::=        exprStmt
                | ifStmt
                ;
                // | whileStmt 
                // | forStmt 
                // | switchStmt 
                // | returnStmt 
                // | continueStmt 
                // | breakStmt; 

exprStmt ::=    expr SEMICOLON;
                //| SEMICOLON;

// Flow Control 
// ! No estan aceptando IDENTIFIERS
ifStmt ::=      IF LPAREN expr RPAREN codeBlock
                | IF LPAREN expr RPAREN codeBlock ELSE codeBlock;

// Expressions
// Las expresiones pueden ser asignaciones, expresiones aritméticas o booleanas o literales.
expr ::=        IDENTIFIER ASSIGN expr
                | literals;
              //  | numExpr 
              //  ; // TODO: Tomar en cuenta la expresion del switch que es solo numerica 

// numExpr ::=     IDENTIFIER PLUS_PLUS 
//                 ;

// Literals
literals ::=      NUMCONST;

// Types
typeSpec ::=      INT 
                | CHAR 
                | LONG 
                | SHORT;