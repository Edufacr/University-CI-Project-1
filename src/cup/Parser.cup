/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        System.out.println("Error de Verdad");
        System.out.println("Error de Sintaxis: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error de Sintaxis: "+ s.value + " Linea "+(s.left+1)+" columna "+(s.right+1) );
    }
:}

/* Terminals (tokens returned by the scanner). */
terminal IDENTIFIER; 
terminal SEMICOLON, ASSIGN, COMMA, RBRACK, LBRACK;
terminal BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, FOR, IF, RETURN, SWITCH, VOID, WHILE;
terminal STATIC;
terminal CONST, CHAR, INT, LONG, SHORT;
terminal READ, WRITE;
terminal Integer NUMCONST;

/* Non terminals */
non terminal program, decs, vars, varDecl, constKey, scopedVarDecl, varDeclInit, varDeclId, typeSpec, functions, varDeclList, simpleExp;

//non terminal Integer    expr;      // used to store evaluated subexpressions

/* The grammar rules */

program ::=     decs;

decs    ::=     vars functions
                | vars; // ! Temporal para que no de error

vars    ::=     vars varDecl 
                | ; //epsilon

varDecl ::= constKey typeSpec varDeclList SEMICOLON
            | error SEMICOLON; // Tirar un error hasta ; pero se recupera 

constKey ::=    CONST 
                | ; //epsilon

scopedVarDecl ::=   STATIC typeSpec varDeclList SEMICOLON 
                    | typeSpec varDeclList SEMICOLON; //mas adelante

varDeclList ::= varDeclList COMMA varDeclInit 
                | varDeclInit;

varDeclInit ::= varDeclId 
                | varDeclId ASSIGN NUMCONST;

varDeclId ::=   IDENTIFIER
                | IDENTIFIER LBRACK NUMCONST RBRACK;

typeSpec ::=  INT 
            | CHAR 
            | LONG 
            | SHORT;